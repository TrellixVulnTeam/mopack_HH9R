{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"mopack \u00a7 mopack (pronounced \"ammopack\" - name subject to change) is an experimental multiple origin package manager, with an emphasis on C/C++ packages. It's designed to allow users to resolve package dependencies from multiple package managers (\"origins\").","title":"Home"},{"location":"#mopack","text":"mopack (pronounced \"ammopack\" - name subject to change) is an experimental multiple origin package manager, with an emphasis on C/C++ packages. It's designed to allow users to resolve package dependencies from multiple package managers (\"origins\").","title":"mopack"},{"location":"about/license/","text":"License \u00a7 BSD 3-clause license \u00a7 Copyright (c) 2020-2022, Jim Porter All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"about/license/#license","text":"","title":"License"},{"location":"about/license/#bsd-3-clause-license","text":"Copyright (c) 2020-2022, Jim Porter All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"BSD 3-clause license"},{"location":"reference/builders/","text":"Builders \u00a7 Builders define how source distributions should be built, allowing you to build dependencies from source even if they use a different build system. bfg9000 \u00a7 options: builders: bfg9000: toolchain: <path> toolchain optional, default : null The path to a bfg9000 toolchain file to use when building bfg-based dependencies. packages: my_pkg: # ... builder: type: bfg9000 extra_args: <shell-args> extra_args optional, default : null A list of extra arguments to pass to bfg9000 configure . If a string is supplied, it will first be split according to POSIX shell rules. cmake \u00a7 options: builders: cmake: toolchain: <path> toolchain optional, default : null The path to a CMake toolchain file to use when building CMake-based dependencies. packages: my_pkg: # ... builder: type: cmake extra_args: <shell-args> extra_args optional, default : null A list of extra arguments to pass to cmake . If a string is supplied, it will first be split according to POSIX shell rules. custom \u00a7 packages: my_pkg: # ... builder: type: custom build_commands: <shell-args-list> deploy_commands: <shell-args-list> build_commands optional, default : null A list of shell commands to execute when building the dependency. Each command can be a list of arguments or a single string (which will be split into arguments according to POSIX shell rules). deploy_commands optional, default : null A list of shell commands to execute when deploying the dependency. Each command can be a list of arguments or a single string (which will be split into arguments according to POSIX shell rules). none \u00a7 packages: my_pkg: # ... builder: type: none","title":"Builders"},{"location":"reference/builders/#builders","text":"Builders define how source distributions should be built, allowing you to build dependencies from source even if they use a different build system.","title":"Builders"},{"location":"reference/builders/#bfg9000","text":"options: builders: bfg9000: toolchain: <path> toolchain optional, default : null The path to a bfg9000 toolchain file to use when building bfg-based dependencies. packages: my_pkg: # ... builder: type: bfg9000 extra_args: <shell-args> extra_args optional, default : null A list of extra arguments to pass to bfg9000 configure . If a string is supplied, it will first be split according to POSIX shell rules.","title":"bfg9000"},{"location":"reference/builders/#cmake","text":"options: builders: cmake: toolchain: <path> toolchain optional, default : null The path to a CMake toolchain file to use when building CMake-based dependencies. packages: my_pkg: # ... builder: type: cmake extra_args: <shell-args> extra_args optional, default : null A list of extra arguments to pass to cmake . If a string is supplied, it will first be split according to POSIX shell rules.","title":"cmake"},{"location":"reference/builders/#custom","text":"packages: my_pkg: # ... builder: type: custom build_commands: <shell-args-list> deploy_commands: <shell-args-list> build_commands optional, default : null A list of shell commands to execute when building the dependency. Each command can be a list of arguments or a single string (which will be split into arguments according to POSIX shell rules). deploy_commands optional, default : null A list of shell commands to execute when deploying the dependency. Each command can be a list of arguments or a single string (which will be split into arguments according to POSIX shell rules).","title":"custom"},{"location":"reference/builders/#none","text":"packages: my_pkg: # ... builder: type: none","title":"none"},{"location":"reference/command-line/","text":"Command-Line Reference \u00a7 Global options \u00a7 -h , --help \u00a7 Print a help message and exit. Equivalent to the help subcommand. --verbose \u00a7 Show verbose output, e.g. the output of build commands during mopack resolve . -c , --color WHEN \u00a7 Show colored output; WHEN is one of always , never , or auto and defaults to auto (i.e. show colored output when the terminal is a tty). -c is equivalent to --color=always . --warn-once \u00a7 Only emit a given warning once. Sub-commands \u00a7 mopack help [ SUBCOMMAND ] \u00a7 Print a help message and exit. If SUBCOMMAND is specified, print help for that subcommand. mopack resolve [ FILE ] \u00a7 Fetch dependencies from their origins and prepare them for use by the current project (e.g. by building them). --directory PATH \u00a7 The directory storing the local package data; defaults to ./mopack . -P TYPE = PATH , --deploy-path TYPE = PATH \u00a7 Set the directory to deploy package data type TYPE to PATH . TYPE is a GNU-like directory variable , such as prefix or bindir . -o OPTION = VALUE , --option OPTION = VALUE \u00a7 Override the common option OPTION to be VALUE . -S OPTION = VALUE , --source-option OPTION = VALUE \u00a7 Override the source option OPTION to be VALUE . -B OPTION = VALUE , --builder-option OPTION = VALUE \u00a7 Override the builder option OPTION to be VALUE . --strict \u00a7 Return an error during mopack usage if the requested dependency is not defined. mopack usage [ DEPENDENCY ] \u00a7 Retrieve information about how to use a dependency. This returns metadata in YAML format (or JSON if --json is passed) pointing to a pkg-config .pc file. --directory PATH \u00a7 The directory storing the local package data; defaults to ./mopack . --json \u00a7 Display usage results as JSON. --strict \u00a7 Return an error if the requested dependency is not defined. mopack deploy \u00a7 Copy the project's dependencies to an installation directory (e.g. as part of running a command like make install ). --directory PATH \u00a7 The directory storing the local package data; defaults to ./mopack . mopack clean \u00a7 Clean the mopack package directory of all files. --directory PATH \u00a7 The directory storing the local package data; defaults to ./mopack . mopack list-files \u00a7 List all the input files used by the current configuration. --directory PATH \u00a7 The directory storing the local package data; defaults to ./mopack . --I , --include-implicit \u00a7 Include implicit input files. --json \u00a7 Display results as JSON. --strict \u00a7 Return an error if the package directory does not exist. mopack list-packages , mopack ls \u00a7 List all the package dependencies. --directory PATH \u00a7 The directory storing the local package data; defaults to ./mopack . --flat \u00a7 List packages without hierarchy. mopack generate-completion \u00a7 Generate shell-completion functions for mopack and write them to standard output. This requires the Python package shtab . -s SHELL , --shell SHELL \u00a7 Specify the shell to generate completion for, e.g. bash . Defaults to the current shell's name.","title":"Command-Line Interface"},{"location":"reference/command-line/#command-line-reference","text":"","title":"Command-Line Reference"},{"location":"reference/command-line/#global-options","text":"","title":"Global options"},{"location":"reference/command-line/#help-option","text":"Print a help message and exit. Equivalent to the help subcommand.","title":"-h, --help"},{"location":"reference/command-line/#verbose","text":"Show verbose output, e.g. the output of build commands during mopack resolve .","title":"--verbose"},{"location":"reference/command-line/#color","text":"Show colored output; WHEN is one of always , never , or auto and defaults to auto (i.e. show colored output when the terminal is a tty). -c is equivalent to --color=always .","title":"-c, --color WHEN"},{"location":"reference/command-line/#warn-once","text":"Only emit a given warning once.","title":"--warn-once"},{"location":"reference/command-line/#sub-commands","text":"","title":"Sub-commands"},{"location":"reference/command-line/#help","text":"Print a help message and exit. If SUBCOMMAND is specified, print help for that subcommand.","title":"mopack help [SUBCOMMAND]"},{"location":"reference/command-line/#resolve","text":"Fetch dependencies from their origins and prepare them for use by the current project (e.g. by building them).","title":"mopack resolve [FILE]"},{"location":"reference/command-line/#resolve-directory","text":"The directory storing the local package data; defaults to ./mopack .","title":"--directory PATH"},{"location":"reference/command-line/#resolve-deploy-path","text":"Set the directory to deploy package data type TYPE to PATH . TYPE is a GNU-like directory variable , such as prefix or bindir .","title":"-P TYPE=PATH, --deploy-path TYPE=PATH"},{"location":"reference/command-line/#resolve-option","text":"Override the common option OPTION to be VALUE .","title":"-o OPTION=VALUE, --option OPTION=VALUE"},{"location":"reference/command-line/#resolve-source-option","text":"Override the source option OPTION to be VALUE .","title":"-S OPTION=VALUE, --source-option OPTION=VALUE"},{"location":"reference/command-line/#resolve-builder-option","text":"Override the builder option OPTION to be VALUE .","title":"-B OPTION=VALUE, --builder-option OPTION=VALUE"},{"location":"reference/command-line/#resolve-strict","text":"Return an error during mopack usage if the requested dependency is not defined.","title":"--strict"},{"location":"reference/command-line/#usage","text":"Retrieve information about how to use a dependency. This returns metadata in YAML format (or JSON if --json is passed) pointing to a pkg-config .pc file.","title":"mopack usage [DEPENDENCY]"},{"location":"reference/command-line/#usage-directory","text":"The directory storing the local package data; defaults to ./mopack .","title":"--directory PATH"},{"location":"reference/command-line/#usage-json","text":"Display usage results as JSON.","title":"--json"},{"location":"reference/command-line/#usage-strict","text":"Return an error if the requested dependency is not defined.","title":"--strict"},{"location":"reference/command-line/#deploy","text":"Copy the project's dependencies to an installation directory (e.g. as part of running a command like make install ).","title":"mopack deploy"},{"location":"reference/command-line/#deploy-directory","text":"The directory storing the local package data; defaults to ./mopack .","title":"--directory PATH"},{"location":"reference/command-line/#clean","text":"Clean the mopack package directory of all files.","title":"mopack clean"},{"location":"reference/command-line/#clean-directory","text":"The directory storing the local package data; defaults to ./mopack .","title":"--directory PATH"},{"location":"reference/command-line/#list-files","text":"List all the input files used by the current configuration.","title":"mopack list-files"},{"location":"reference/command-line/#list-files-directory","text":"The directory storing the local package data; defaults to ./mopack .","title":"--directory PATH"},{"location":"reference/command-line/#list-files-include-implicit","text":"Include implicit input files.","title":"--I, --include-implicit"},{"location":"reference/command-line/#list-files-json","text":"Display results as JSON.","title":"--json"},{"location":"reference/command-line/#usage-strict","text":"Return an error if the package directory does not exist.","title":"--strict"},{"location":"reference/command-line/#list-packages","text":"List all the package dependencies.","title":"mopack list-packages, mopack ls"},{"location":"reference/command-line/#list-packages-directory","text":"The directory storing the local package data; defaults to ./mopack .","title":"--directory PATH"},{"location":"reference/command-line/#list-packages-flat","text":"List packages without hierarchy.","title":"--flat"},{"location":"reference/command-line/#generate-completion","text":"Generate shell-completion functions for mopack and write them to standard output. This requires the Python package shtab .","title":"mopack generate-completion"},{"location":"reference/command-line/#generate-completion-shell","text":"Specify the shell to generate completion for, e.g. bash . Defaults to the current shell's name.","title":"-s SHELL, --shell SHELL"},{"location":"reference/environment-vars/","text":"Environment Variables \u00a7 mopack reads from a number of environment variables. Below is a full list of all the environment variables mopack recognizes. Command variables \u00a7 ADD_APT_REPOSITORY \u00a7 Default: sudo add-apt-repository The command to use when adding an apt repository. APT_GET \u00a7 Default: sudo apt-get The command to use when installing an apt package. BFG9000 \u00a7 Default: bfg9000 The command to use when configuring a bfg9000 -based project. CONAN \u00a7 Default: conan The command to use when installing a conan package. CMAKE \u00a7 Default: cmake The command to use when configuring a CMake -based project. DPKG_QUERY \u00a7 Default: dpkg-query The command to use when querying an apt package. GIT \u00a7 Default: git The command to use when working with a git repository. NINJA \u00a7 Default: ninja The command to use when building via the Ninja build system. PATCH \u00a7 Default: patch The command to use when applying a patch file. Package variables \u00a7 BOOST_ROOT \u00a7 Default: none The root directory where Boost headers and libraries are stored (as $BOOST_ROOT/include and $BOOST_ROOT/lib , respectively). BOOST_INCLUDEDIR \u00a7 Default: none The root directory where Boost headers are stored. This takes precedence over $BOOST_ROOT . BOOST_LIBRARYDIR \u00a7 Default: none The root directory where Boost libraries are stored. This takes precedence over $BOOST_ROOT . QT_ROOT \u00a7 Default: none The root directory where Qt headers and libraries are stored (as $QT_ROOT/include:$QT_ROOT/include/Qt and $QT_ROOT/lib , respectively). QT_INCLUDEDIR \u00a7 Default: none The root directory where Qt headers are stored. This takes precedence over $QT_ROOT . QT_LIBRARYDIR \u00a7 Default: none The root directory where Qt libraries are stored. This takes precedence over $QT_ROOT . System variables \u00a7 CLICOLOR \u00a7 Default: none If set to 0 , disable colors in terminal output, overriding the --color option and tty detection. If set to non-zero, enable colors if outputting to a tty. CLICOLOR_FORCE \u00a7 Default: none If set to non-zero, enable colors in the terminal output regardless of whether the destination is a tty. This overrides $CLICOLOR .","title":"Environment Variables"},{"location":"reference/environment-vars/#environment-variables","text":"mopack reads from a number of environment variables. Below is a full list of all the environment variables mopack recognizes.","title":"Environment Variables"},{"location":"reference/environment-vars/#command-variables","text":"","title":"Command variables"},{"location":"reference/environment-vars/#add_apt_repository","text":"Default: sudo add-apt-repository The command to use when adding an apt repository.","title":"ADD_APT_REPOSITORY"},{"location":"reference/environment-vars/#apt_get","text":"Default: sudo apt-get The command to use when installing an apt package.","title":"APT_GET"},{"location":"reference/environment-vars/#bfg9000","text":"Default: bfg9000 The command to use when configuring a bfg9000 -based project.","title":"BFG9000"},{"location":"reference/environment-vars/#conan","text":"Default: conan The command to use when installing a conan package.","title":"CONAN"},{"location":"reference/environment-vars/#cmake","text":"Default: cmake The command to use when configuring a CMake -based project.","title":"CMAKE"},{"location":"reference/environment-vars/#dpkg_query","text":"Default: dpkg-query The command to use when querying an apt package.","title":"DPKG_QUERY"},{"location":"reference/environment-vars/#git","text":"Default: git The command to use when working with a git repository.","title":"GIT"},{"location":"reference/environment-vars/#ninja","text":"Default: ninja The command to use when building via the Ninja build system.","title":"NINJA"},{"location":"reference/environment-vars/#patch","text":"Default: patch The command to use when applying a patch file.","title":"PATCH"},{"location":"reference/environment-vars/#package-variables","text":"","title":"Package variables"},{"location":"reference/environment-vars/#boost_root","text":"Default: none The root directory where Boost headers and libraries are stored (as $BOOST_ROOT/include and $BOOST_ROOT/lib , respectively).","title":"BOOST_ROOT"},{"location":"reference/environment-vars/#boost_includedir","text":"Default: none The root directory where Boost headers are stored. This takes precedence over $BOOST_ROOT .","title":"BOOST_INCLUDEDIR"},{"location":"reference/environment-vars/#boost_librarydir","text":"Default: none The root directory where Boost libraries are stored. This takes precedence over $BOOST_ROOT .","title":"BOOST_LIBRARYDIR"},{"location":"reference/environment-vars/#qt_root","text":"Default: none The root directory where Qt headers and libraries are stored (as $QT_ROOT/include:$QT_ROOT/include/Qt and $QT_ROOT/lib , respectively).","title":"QT_ROOT"},{"location":"reference/environment-vars/#qt_includedir","text":"Default: none The root directory where Qt headers are stored. This takes precedence over $QT_ROOT .","title":"QT_INCLUDEDIR"},{"location":"reference/environment-vars/#qt_librarydir","text":"Default: none The root directory where Qt libraries are stored. This takes precedence over $QT_ROOT .","title":"QT_LIBRARYDIR"},{"location":"reference/environment-vars/#system-variables","text":"","title":"System variables"},{"location":"reference/environment-vars/#clicolor","text":"Default: none If set to 0 , disable colors in terminal output, overriding the --color option and tty detection. If set to non-zero, enable colors if outputting to a tty.","title":"CLICOLOR"},{"location":"reference/environment-vars/#clicolor_force","text":"Default: none If set to non-zero, enable colors in the terminal output regardless of whether the destination is a tty. This overrides $CLICOLOR .","title":"CLICOLOR_FORCE"},{"location":"reference/packages/","text":"Packages \u00a7 Package configurations describe how to fetch a particular dependency as well as all the necessary details to actually use it in the parent project. packages: my_pkg: source: <package-source> inherit_defaults: <boolean> deploy: <boolean> submodules: <submodules> source required The type of dependency, corresponding to a particular origin (e.g. a package manager); see below for possible values. inherit_defaults optional, default : false If true, inherit any unspecified values for this dependency from the defaults for the package. Defaults to false; however, any packages requested via mopack usage but not defined will use the defaults. deploy optional, default : true If true, deploy this package when calling mopack deploy . submodules optional, default : null A list of available submodules, or * to indicate that any submodule name should be accepted. If this is specified, using this package via mopack usage must specify a submodule. To declare that submodules are optional for usage, you can specify a dictionary: submodules: names: <submodules> required: false Source distributions \u00a7 directory \u00a7 packages: my_pkg: source: directory path: <path> build: <build> usage: <usage> path required The path to the source directory of the dependency. build required The builder to use when resolving this package. Note that while this is required, it can be unset if the dependency defines the builder in its export section. usage optional, default : from builder The usage to use when using this package. Some builders require this to be set, but others provide a default usage specification; the dependency can also define the usage in its export section. git \u00a7 packages: my_pkg: source: git repository: <url-or-path> tag: <tag-name> # or... branch: <branch-name> # or... commit: <commit-sha> srcdir: <inner-path> build: <build> usage: <usage> repository required The URL or path to the repository. tag optional branch commit The tag, branch, or commit to check out. At most one of these may be specified. srcdir optional; default: . The directory within the repository containing the dependency's source code. build required The builder to use when resolving this package. Note that while this is required, it can be unset if the dependency defines the builder in its export section. usage optional, default: from builder The usage to use when using this package. Some builders require this to be set, but others provide a default usage specification; the dependency can also define the usage in its export section. tarball \u00a7 packages: my_pkg: source: tarball path: <path> # or... url: <url> files: <glob-list> srcdir: <inner-path> patch: <path> build: <build> usage: <usage> path required url The path or URL to the archive. Exactly one of these must be specified. files optional; default: null A glob or list of globs to filter the files extracted from the archive. If unspecified, extract everything. srcdir optional; default: . The directory within the repository containing the dependency's source code. patch optional; default: null The path to a patch file to apply to the extract source files. build required The builder to use when resolving this package. Note that while this is required, it can be unset if the dependency defines the builder in its export section. usage optional, default: from builder The usage to use when using this package. Some builders require this to be set, but others provide a default usage specification; the dependency can also define the usage in its export section. Other sources \u00a7 apt \u00a7 packages: my_pkg: source: apt remote: <string-list> repository: <string> usage: <usage> remote optional; default: lib{package}-dev The Apt package(s) to fetch when resolving this package. repository optional; default: null The Apt repository to fetch the package(s) from. If not specified, use the default repositories for the system. usage optional, default: system The usage to use when using this package. conan \u00a7 options: sources: conan: build: <string-list> extra_args: <shell-args> build optional; default: null A string (or list of strings) of packages that Conan should explicitly build. This corresponds to --build=<pkg> on the conan install command line for each pkg . You can also specify all to build everything (equivalent to --build ). extra_args optional, default : null A list of extra arguments to pass to conan install . If a string is supplied, it will first be split according to POSIX shell rules. packages: my_pkg: source: conan remote: <string> build: <boolean> options: my_option: <string-or-boolean> usage: <usage> remote required The specifier for the package in the Conan repository, e.g. zlib/1.2.11 . build optional; default: false True if the package should be built from source; false otherwise. options optional; default: {} A dictionary of options to pass to Conan; for example, you could pass shared: true to request a shared library configuration. usage optional, default: pkg_config The usage to use when using this package. system \u00a7 packages: my_pkg: source: system auto_link: <boolean> version: <string> pcname: <string> dependencies: <dependency-list> include_path: <path-list> library_path: <path-list> headers: <header-list> libraries: <library-list> compile_flags: <shell-args> link_flags: <shell-args> submodule_map: <submodule-map> # or... submodule_map: my_submodule: <submodule-map> '*': <submodule-map>","title":"Packages"},{"location":"reference/packages/#packages","text":"Package configurations describe how to fetch a particular dependency as well as all the necessary details to actually use it in the parent project. packages: my_pkg: source: <package-source> inherit_defaults: <boolean> deploy: <boolean> submodules: <submodules> source required The type of dependency, corresponding to a particular origin (e.g. a package manager); see below for possible values. inherit_defaults optional, default : false If true, inherit any unspecified values for this dependency from the defaults for the package. Defaults to false; however, any packages requested via mopack usage but not defined will use the defaults. deploy optional, default : true If true, deploy this package when calling mopack deploy . submodules optional, default : null A list of available submodules, or * to indicate that any submodule name should be accepted. If this is specified, using this package via mopack usage must specify a submodule. To declare that submodules are optional for usage, you can specify a dictionary: submodules: names: <submodules> required: false","title":"Packages"},{"location":"reference/packages/#source-distributions","text":"","title":"Source distributions"},{"location":"reference/packages/#directory","text":"packages: my_pkg: source: directory path: <path> build: <build> usage: <usage> path required The path to the source directory of the dependency. build required The builder to use when resolving this package. Note that while this is required, it can be unset if the dependency defines the builder in its export section. usage optional, default : from builder The usage to use when using this package. Some builders require this to be set, but others provide a default usage specification; the dependency can also define the usage in its export section.","title":"directory"},{"location":"reference/packages/#git","text":"packages: my_pkg: source: git repository: <url-or-path> tag: <tag-name> # or... branch: <branch-name> # or... commit: <commit-sha> srcdir: <inner-path> build: <build> usage: <usage> repository required The URL or path to the repository. tag optional branch commit The tag, branch, or commit to check out. At most one of these may be specified. srcdir optional; default: . The directory within the repository containing the dependency's source code. build required The builder to use when resolving this package. Note that while this is required, it can be unset if the dependency defines the builder in its export section. usage optional, default: from builder The usage to use when using this package. Some builders require this to be set, but others provide a default usage specification; the dependency can also define the usage in its export section.","title":"git"},{"location":"reference/packages/#tarball","text":"packages: my_pkg: source: tarball path: <path> # or... url: <url> files: <glob-list> srcdir: <inner-path> patch: <path> build: <build> usage: <usage> path required url The path or URL to the archive. Exactly one of these must be specified. files optional; default: null A glob or list of globs to filter the files extracted from the archive. If unspecified, extract everything. srcdir optional; default: . The directory within the repository containing the dependency's source code. patch optional; default: null The path to a patch file to apply to the extract source files. build required The builder to use when resolving this package. Note that while this is required, it can be unset if the dependency defines the builder in its export section. usage optional, default: from builder The usage to use when using this package. Some builders require this to be set, but others provide a default usage specification; the dependency can also define the usage in its export section.","title":"tarball"},{"location":"reference/packages/#other-sources","text":"","title":"Other sources"},{"location":"reference/packages/#apt","text":"packages: my_pkg: source: apt remote: <string-list> repository: <string> usage: <usage> remote optional; default: lib{package}-dev The Apt package(s) to fetch when resolving this package. repository optional; default: null The Apt repository to fetch the package(s) from. If not specified, use the default repositories for the system. usage optional, default: system The usage to use when using this package.","title":"apt"},{"location":"reference/packages/#conan","text":"options: sources: conan: build: <string-list> extra_args: <shell-args> build optional; default: null A string (or list of strings) of packages that Conan should explicitly build. This corresponds to --build=<pkg> on the conan install command line for each pkg . You can also specify all to build everything (equivalent to --build ). extra_args optional, default : null A list of extra arguments to pass to conan install . If a string is supplied, it will first be split according to POSIX shell rules. packages: my_pkg: source: conan remote: <string> build: <boolean> options: my_option: <string-or-boolean> usage: <usage> remote required The specifier for the package in the Conan repository, e.g. zlib/1.2.11 . build optional; default: false True if the package should be built from source; false otherwise. options optional; default: {} A dictionary of options to pass to Conan; for example, you could pass shared: true to request a shared library configuration. usage optional, default: pkg_config The usage to use when using this package.","title":"conan"},{"location":"reference/packages/#system","text":"packages: my_pkg: source: system auto_link: <boolean> version: <string> pcname: <string> dependencies: <dependency-list> include_path: <path-list> library_path: <path-list> headers: <header-list> libraries: <library-list> compile_flags: <shell-args> link_flags: <shell-args> submodule_map: <submodule-map> # or... submodule_map: my_submodule: <submodule-map> '*': <submodule-map>","title":"system"},{"location":"reference/usage/","text":"Usage \u00a7 Usage defines how to include a package in part of your build process. These definitions are used to generate a pkg-config .pc file (or to point to an existing one), which can then be used when compiling or linking your project. packages: my_pkg: # ... usage: type: <usage-type> inherit_defaults: <boolean> submodule_map: <submodule-map> # or... submodule_map: my_submodule: <submodule-map> '*': <submodule-map> path/system \u00a7 packages: my_pkg: # ... usage: type: path # or ... type: system auto_link: <boolean> version: <string> pcname: <string> # system only dependencies: <dependency-list> include_path: <path-list> library_path: <path-list> headers: <header-list> libraries: <library-list> compile_flags: <shell-args> link_flags: <shell-args> pkg_config \u00a7 packages: my_pkg: # ... usage: type: pkg_config pcname: <string> pkg_config_path: <path-list> pcname optional, default : package name The name of the pkg-config .pc file, without the extension. If submodules are required for this package, this instead defaults to null . pkg_config_path optional, default : null The path to look for the pkg-config file in. If not specified, use the default path for pkg-config. package: my_pkg: # ... usage: submodule_map: pcname: <string> pcname optional, default : '<package>_<submodule>' The name of the pkg-config .pc file for the submodule, without the extension.","title":"Usage"},{"location":"reference/usage/#usage","text":"Usage defines how to include a package in part of your build process. These definitions are used to generate a pkg-config .pc file (or to point to an existing one), which can then be used when compiling or linking your project. packages: my_pkg: # ... usage: type: <usage-type> inherit_defaults: <boolean> submodule_map: <submodule-map> # or... submodule_map: my_submodule: <submodule-map> '*': <submodule-map>","title":"Usage"},{"location":"reference/usage/#pathsystem","text":"packages: my_pkg: # ... usage: type: path # or ... type: system auto_link: <boolean> version: <string> pcname: <string> # system only dependencies: <dependency-list> include_path: <path-list> library_path: <path-list> headers: <header-list> libraries: <library-list> compile_flags: <shell-args> link_flags: <shell-args>","title":"path/system"},{"location":"reference/usage/#pkg_config","text":"packages: my_pkg: # ... usage: type: pkg_config pcname: <string> pkg_config_path: <path-list> pcname optional, default : package name The name of the pkg-config .pc file, without the extension. If submodules are required for this package, this instead defaults to null . pkg_config_path optional, default : null The path to look for the pkg-config file in. If not specified, use the default path for pkg-config. package: my_pkg: # ... usage: submodule_map: pcname: <string> pcname optional, default : '<package>_<submodule>' The name of the pkg-config .pc file for the submodule, without the extension.","title":"pkg_config"},{"location":"user/resolving/","text":"Resolving Packages With mopack \u00a7 Most package managers allow developers to pull dependencies from a remote source and prepare them for use by your build system. In this regard, mopack is no different. Note mopack is careful not to use the term \"install\"; depending on context, installation can refer to one of two very-different concepts: Resolve : to fetch a dependency from its origin and prepare it (usually by building) for use by the root project (e.g. conan install ) Deploy : to copy any files from the dependency needed for running the root project into their final locations (e.g. make install ) Resolution \u00a7 The first step in working with dependencies is, unsurprisingly, getting them. This is really two sub-steps rolled into one: fetching and building. This typically involves downloading the appropriate files from some remote source (possibly recursively in the case of source distributions ) and then compiling any projects as needed in the proper order, using their respective build systems. In most cases, this step should occur before configuration of the root project's build (for build configuration systems that natively support mopack, such as bfg9000 , this happens automatically). However, when run manually, users should invoke the following command: $ mopack resolve /path/to/project/ This will get all the dependencies specified in /path/to/project/mopack.yml and collect the info necessary to use them in ./mopack/ . If your build dir is not the current directory, you can specify another location with --directory /path/to/builddir/ . You can also specify multiple paths when resolving, including specific filenames: $ mopack resolve . mopack-special.yml This can be useful for providing alternate configurations or for adding mopack configurations automatically generated by a tool. Note Packages and options specified in later files override previous values. Local configuration \u00a7 Projects that use mopack often contain their own mopack.yml configuration; however, when building such a project, you may not want to use this configuration (or may only want to use parts of it). In this case, you can provide your own mopack-local.yml file to override the project's configuration. When passing a directory to mopack resolve , mopack will look for both mopack.yml and mopack-local.yml , with any packages or options specified in the latter file will override those in the former. Thus, if both mopack.yml and mopack-local.yml exist, mopack resolve . is equivalent to: $ mopack resolve mopack.yml mopack-local.yml Usage \u00a7 Once a project's dependencies are ready to use, the next step is actually using them. Generally, this step occurs during the root project's configuration step. To get a package's usage information, run the following command: $ mopack usage some-package This will return the package's usage information in YAML format (or JSON if --json is passed), which can then be fed to the dependent build steps. Some packages contain submodules , representing optional components that you may or may not want to use (e.g. individual libraries from the Boost package). In this case, you can specify the submodules you want to use in a particular situation when invoking mopack usage : $ mopack usage 'some-package[submodule1,submodule2]' Deployment \u00a7 Finally, some projects may want to deploy dependencies alongside the project's own binaries (e.g. when running make install ). This step (generally performed during the root project's make install process, naturally) runs whatever commands are necessary for each dependency to deploy them to the final destination: $ mopack deploy Any dependency whose deploy property is true (the default) will then be deployed.","title":"Resolving Packages With mopack"},{"location":"user/resolving/#resolving-packages-with-mopack","text":"Most package managers allow developers to pull dependencies from a remote source and prepare them for use by your build system. In this regard, mopack is no different. Note mopack is careful not to use the term \"install\"; depending on context, installation can refer to one of two very-different concepts: Resolve : to fetch a dependency from its origin and prepare it (usually by building) for use by the root project (e.g. conan install ) Deploy : to copy any files from the dependency needed for running the root project into their final locations (e.g. make install )","title":"Resolving Packages With mopack"},{"location":"user/resolving/#resolution","text":"The first step in working with dependencies is, unsurprisingly, getting them. This is really two sub-steps rolled into one: fetching and building. This typically involves downloading the appropriate files from some remote source (possibly recursively in the case of source distributions ) and then compiling any projects as needed in the proper order, using their respective build systems. In most cases, this step should occur before configuration of the root project's build (for build configuration systems that natively support mopack, such as bfg9000 , this happens automatically). However, when run manually, users should invoke the following command: $ mopack resolve /path/to/project/ This will get all the dependencies specified in /path/to/project/mopack.yml and collect the info necessary to use them in ./mopack/ . If your build dir is not the current directory, you can specify another location with --directory /path/to/builddir/ . You can also specify multiple paths when resolving, including specific filenames: $ mopack resolve . mopack-special.yml This can be useful for providing alternate configurations or for adding mopack configurations automatically generated by a tool. Note Packages and options specified in later files override previous values.","title":"Resolution"},{"location":"user/resolving/#local-configuration","text":"Projects that use mopack often contain their own mopack.yml configuration; however, when building such a project, you may not want to use this configuration (or may only want to use parts of it). In this case, you can provide your own mopack-local.yml file to override the project's configuration. When passing a directory to mopack resolve , mopack will look for both mopack.yml and mopack-local.yml , with any packages or options specified in the latter file will override those in the former. Thus, if both mopack.yml and mopack-local.yml exist, mopack resolve . is equivalent to: $ mopack resolve mopack.yml mopack-local.yml","title":"Local configuration"},{"location":"user/resolving/#usage","text":"Once a project's dependencies are ready to use, the next step is actually using them. Generally, this step occurs during the root project's configuration step. To get a package's usage information, run the following command: $ mopack usage some-package This will return the package's usage information in YAML format (or JSON if --json is passed), which can then be fed to the dependent build steps. Some packages contain submodules , representing optional components that you may or may not want to use (e.g. individual libraries from the Boost package). In this case, you can specify the submodules you want to use in a particular situation when invoking mopack usage : $ mopack usage 'some-package[submodule1,submodule2]'","title":"Usage"},{"location":"user/resolving/#deployment","text":"Finally, some projects may want to deploy dependencies alongside the project's own binaries (e.g. when running make install ). This step (generally performed during the root project's make install process, naturally) runs whatever commands are necessary for each dependency to deploy them to the final destination: $ mopack deploy Any dependency whose deploy property is true (the default) will then be deployed.","title":"Deployment"},{"location":"user/writing/","text":"Writing mopack.yml Configurations \u00a7 Your first configuration \u00a7 The absolute simplest mopack configuration is an empty file, in which any requested dependencies are assumed to be system dependencies . However, that's not very interesting. Instead, let's look at a basic mopack.yml configuration that specifies a dependent package fetched and built from a tarball: packages: foo_pkg: source: tarball url: https://phobos.uac/foo_pkg-1.0.tar.gz build: bfg9000 This informs mopack that it should fetch a tarball from the specified URL and then build it using the bfg9000 builder. Configuring builds/usage \u00a7 In the above example, mopack builds foo_pkg using the default settings for bfg9000. However, sometimes you may need to provide additional configuration options for the build: packages: foo_pkg: source: tarball url: https://phobos.uac/foo_pkg-1.0.tar.gz build: type: bfg9000 extra_args: --extra usage: type: pkg_config pcname: foobar Here, instead of a string for build , we specify a dictionary indicating the type of the build and some extra arguments to be passed to it. Below, we'll show a more complex example taking advantage of variable interpolation . We also explicitly specify a usage . A usage, as the name implies, describes how a package should be used , e.g. where to find header files, what libraries to link to, etc. Other package sources \u00a7 One of the primary benefits of mopack is that packages can come from multiple different origins, or sources. These include other source distributions similar to tarball , such as directory or git , as well as full-fledged package managers like apt or conan : packages: zlib: source: conan remote: zlib/1.2.11 Project-wide options \u00a7 In addition to specifying configuration options for a particular package, you can also specify options for all packages, or all those of a particular type: options: target_platform: linux builders: bfg9000: toolchain: /path/to/toolchain.bfg sources: conan: build: missing packages: # ... This is especially useful for build system integration, e.g. for passing a toolchain file set during configuration of the root project on to package dependencies. Nested dependencies \u00a7 When your project depends on a source distribution, that dependency might depend on other packages in turn. mopack handles this automatically, and will add nested dependencies to the list of packages to resolve. For example, if foo_pkg above contains a mopack.yml as follows, then when we resolve our main mopack.yml configuration, bar_pkg will be fetched and built so that foo_pkg can use it during its build: packages: bar_pkg: source: tarball url: https://phobos.uac/bar_pkg-2.0.tar.gz build: bfg9000 Overriding nested dependencies \u00a7 Sometimes, you may not want to use the nested dependencies as-is from other packages. In this case, you can simply provide your own configuration in the parent mopack.yml : packages: foo_pkg: source: tarball url: https://phobos.uac/foo_pkg-1.0.tar.gz build: bfg9000 bar_pkg: source: tarball url: https://phobos.uac/bar_pkg-2.1.tar.gz build: bfg9000 When doing so, mopack will automatically determine the appropriate order to build dependencies so that each package has all of its build requirements met. Note In situations where one package depends on another, but the former package does not specify any mopack dependencies, you can ensure the correct build order by putting the inner dependency first in your mopack.yml file. Then, mopack will fetch and build that package first before proceeding to the next one. Exporting package configuration \u00a7 When creating a source distribution package, you can make it easier to use this package by exporting its configuration. This allows users of your package to omit the details about how to build and use the package. For example, you can include the following in your package's mopack.yml file: export: build: bfg9000 Then, users of your package can omit those fields from their configuration, relying on mopack to fill in the blanks: packages: foo_pkg: source: tarball url: https://phobos.uac/foo_pkg-1.0.tar.gz Of course, the parent configuration can still override the values set by a dependency simply by including the appropriate configuration setting, as in our first example . Variable interpolation \u00a7 For more advanced scenarios, you can take advantage of variable interpolation to programmatically specify package configurations. For example, suppose we wanted to (partially) rewrite our first configuration using a custom builder: packages: foo_pkg: source: tarball url: https://phobos.uac/foo_pkg-1.0.tar.gz build: type: custom build_commands: - bfg9000 configure $builddir - cd $builddir - ninja usage: pkg_config Here, $builddir represents a unique path for the current project that it can use as a build directory. You can also spell this variable as ${{builddir}} , which can be useful if you need to append some alphanumeric characters to the variable's value. Interpolating expressions \u00a7 The above configuration works for building a package, but not for deploying it: we haven't told the build system where to copy foo_pkg 's files. Here, we can take advantage of expression interpolation to conditionally pass command line arguments to bfg9000: packages: foo_pkg: source: tarball url: https://phobos.uac/foo_pkg-1.0.tar.gz build: type: custom build_commands: - >- bfg9000 configure $builddir ${{ deploy_paths['prefix'] ? '--prefix=' + deploy_paths['prefix'] : '' }} - cd $builddir/. - ninja deploy_commands: - ninja install usage: pkg_config Conditional package specification \u00a7 In some cases, a package's configuration should be much different depending on the state of a variable, and the variable interpolation described above isn't flexible enough to support this easily. To support this, a package's configuration can be specified as a list of configurations with an added if key to describe the conditions to use a particular configuration. Note that, since if always takes an expression, the $ / ${{ }} sigil is not required: packages: foo_pkg: - if: host_platform == 'linux' source: apt - source: tarball url: https://phobos.uac/foo_pkg-1.0.tar.gz build: bfg9000 The conditional for each configuration is evaluated in turn, selecting the first configuration where its conditional is true. If the last configuration has no if key, it will always be selected as a last resort; otherwise, if no conditional is satisfied, the package will be undefined. Submodules \u00a7 In mopack, a \"package\" represents a single unit distributed in its most-typical form. Thus Boost, despite containing a wide variety of libraries, is still a single package. However, for a package like Boost, users rarely need to use the entirety of the package. In this case, a package can be divided into submodules. A submodule represents the smallest usable unit of a package; in Boost's case, a single Boost library. At its simplest, defining submodules for a package consists of listing the available submodule names: packages: hello: source: tarball path: greeter-1.0.tar.gz build: bfg9000 submodules: ['french', 'english'] This specifies a package with two submodules, requiring at least one to be specified whenever mopack usage is invoked.","title":"Writing mopack.yml Configurations"},{"location":"user/writing/#writing-mopackyml-configurations","text":"","title":"Writing mopack.yml Configurations"},{"location":"user/writing/#your-first-configuration","text":"The absolute simplest mopack configuration is an empty file, in which any requested dependencies are assumed to be system dependencies . However, that's not very interesting. Instead, let's look at a basic mopack.yml configuration that specifies a dependent package fetched and built from a tarball: packages: foo_pkg: source: tarball url: https://phobos.uac/foo_pkg-1.0.tar.gz build: bfg9000 This informs mopack that it should fetch a tarball from the specified URL and then build it using the bfg9000 builder.","title":"Your first configuration"},{"location":"user/writing/#configuring-buildsusage","text":"In the above example, mopack builds foo_pkg using the default settings for bfg9000. However, sometimes you may need to provide additional configuration options for the build: packages: foo_pkg: source: tarball url: https://phobos.uac/foo_pkg-1.0.tar.gz build: type: bfg9000 extra_args: --extra usage: type: pkg_config pcname: foobar Here, instead of a string for build , we specify a dictionary indicating the type of the build and some extra arguments to be passed to it. Below, we'll show a more complex example taking advantage of variable interpolation . We also explicitly specify a usage . A usage, as the name implies, describes how a package should be used , e.g. where to find header files, what libraries to link to, etc.","title":"Configuring builds/usage"},{"location":"user/writing/#other-package-sources","text":"One of the primary benefits of mopack is that packages can come from multiple different origins, or sources. These include other source distributions similar to tarball , such as directory or git , as well as full-fledged package managers like apt or conan : packages: zlib: source: conan remote: zlib/1.2.11","title":"Other package sources"},{"location":"user/writing/#project-wide-options","text":"In addition to specifying configuration options for a particular package, you can also specify options for all packages, or all those of a particular type: options: target_platform: linux builders: bfg9000: toolchain: /path/to/toolchain.bfg sources: conan: build: missing packages: # ... This is especially useful for build system integration, e.g. for passing a toolchain file set during configuration of the root project on to package dependencies.","title":"Project-wide options"},{"location":"user/writing/#nested-dependencies","text":"When your project depends on a source distribution, that dependency might depend on other packages in turn. mopack handles this automatically, and will add nested dependencies to the list of packages to resolve. For example, if foo_pkg above contains a mopack.yml as follows, then when we resolve our main mopack.yml configuration, bar_pkg will be fetched and built so that foo_pkg can use it during its build: packages: bar_pkg: source: tarball url: https://phobos.uac/bar_pkg-2.0.tar.gz build: bfg9000","title":"Nested dependencies"},{"location":"user/writing/#overriding-nested-dependencies","text":"Sometimes, you may not want to use the nested dependencies as-is from other packages. In this case, you can simply provide your own configuration in the parent mopack.yml : packages: foo_pkg: source: tarball url: https://phobos.uac/foo_pkg-1.0.tar.gz build: bfg9000 bar_pkg: source: tarball url: https://phobos.uac/bar_pkg-2.1.tar.gz build: bfg9000 When doing so, mopack will automatically determine the appropriate order to build dependencies so that each package has all of its build requirements met. Note In situations where one package depends on another, but the former package does not specify any mopack dependencies, you can ensure the correct build order by putting the inner dependency first in your mopack.yml file. Then, mopack will fetch and build that package first before proceeding to the next one.","title":"Overriding nested dependencies"},{"location":"user/writing/#exporting-package-configuration","text":"When creating a source distribution package, you can make it easier to use this package by exporting its configuration. This allows users of your package to omit the details about how to build and use the package. For example, you can include the following in your package's mopack.yml file: export: build: bfg9000 Then, users of your package can omit those fields from their configuration, relying on mopack to fill in the blanks: packages: foo_pkg: source: tarball url: https://phobos.uac/foo_pkg-1.0.tar.gz Of course, the parent configuration can still override the values set by a dependency simply by including the appropriate configuration setting, as in our first example .","title":"Exporting package configuration"},{"location":"user/writing/#variable-interpolation","text":"For more advanced scenarios, you can take advantage of variable interpolation to programmatically specify package configurations. For example, suppose we wanted to (partially) rewrite our first configuration using a custom builder: packages: foo_pkg: source: tarball url: https://phobos.uac/foo_pkg-1.0.tar.gz build: type: custom build_commands: - bfg9000 configure $builddir - cd $builddir - ninja usage: pkg_config Here, $builddir represents a unique path for the current project that it can use as a build directory. You can also spell this variable as ${{builddir}} , which can be useful if you need to append some alphanumeric characters to the variable's value.","title":"Variable interpolation"},{"location":"user/writing/#interpolating-expressions","text":"The above configuration works for building a package, but not for deploying it: we haven't told the build system where to copy foo_pkg 's files. Here, we can take advantage of expression interpolation to conditionally pass command line arguments to bfg9000: packages: foo_pkg: source: tarball url: https://phobos.uac/foo_pkg-1.0.tar.gz build: type: custom build_commands: - >- bfg9000 configure $builddir ${{ deploy_paths['prefix'] ? '--prefix=' + deploy_paths['prefix'] : '' }} - cd $builddir/. - ninja deploy_commands: - ninja install usage: pkg_config","title":"Interpolating expressions"},{"location":"user/writing/#conditional-package-specification","text":"In some cases, a package's configuration should be much different depending on the state of a variable, and the variable interpolation described above isn't flexible enough to support this easily. To support this, a package's configuration can be specified as a list of configurations with an added if key to describe the conditions to use a particular configuration. Note that, since if always takes an expression, the $ / ${{ }} sigil is not required: packages: foo_pkg: - if: host_platform == 'linux' source: apt - source: tarball url: https://phobos.uac/foo_pkg-1.0.tar.gz build: bfg9000 The conditional for each configuration is evaluated in turn, selecting the first configuration where its conditional is true. If the last configuration has no if key, it will always be selected as a last resort; otherwise, if no conditional is satisfied, the package will be undefined.","title":"Conditional package specification"},{"location":"user/writing/#submodules","text":"In mopack, a \"package\" represents a single unit distributed in its most-typical form. Thus Boost, despite containing a wide variety of libraries, is still a single package. However, for a package like Boost, users rarely need to use the entirety of the package. In this case, a package can be divided into submodules. A submodule represents the smallest usable unit of a package; in Boost's case, a single Boost library. At its simplest, defining submodules for a package consists of listing the available submodule names: packages: hello: source: tarball path: greeter-1.0.tar.gz build: bfg9000 submodules: ['french', 'english'] This specifies a package with two submodules, requiring at least one to be specified whenever mopack usage is invoked.","title":"Submodules"}]}